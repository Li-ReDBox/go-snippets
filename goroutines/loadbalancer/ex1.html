<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Summary of Concurrency Is Not Parallellism, a talk by Rob Pike - Rakhim.org</title><link rel=stylesheet href=ex1_files/style.css><script src=https://identity.netlify.com/v1/netlify-identity-widget.js></script><script src=//static.getclicky.com/js type=text/javascript></script><script type=text/javascript>try{clicky.init(101132832);}catch(e){}</script><noscript><p><img alt=Clicky width=1 height=1 src=//in.getclicky.com/101132832ns.gif></p></noscript><link rel=icon type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon-precomposed href=/favicon.png></head><body class="site site-blog"><div class=site-content><main class=container><nav class=main-nav><p><a href=/>Home</a>
<span class=text-muted>|</span>
<a href=https://blog.rakhim.org>Blog</a>
<span class=text-muted>|</span>
<a href=/about>About</a>
<span class=text-muted>|</span>
<a href=https://codexpanse.com>Courses</a>
<span class=text-muted>|</span>
<a href=/talks>Talks</a>
<span class=text-muted>|</span>
<a href=/honestly-undefined>Comics</a>
<span class=text-muted>|</span>
<a href=/bookshelf>Bookshelf</a>
<span class=text-muted>|</span>
<a href=https://www.youtube.com/c/codexpanse>YT</a>
<span class=text-muted>|</span>
<a href=https://twitter.com/freetonik>TW</a>
<span class=text-muted>|</span>
<a href=/index.xml>RSS</a><p></nav><hr><div class=article-meta><h1>Summary of Concurrency Is Not Parallellism, a talk by Rob Pike</h1><small class="date text-muted text-light">December 20, 2019</small></div><article><p>This is a complete summary of an excellent talk by Rob Pike <a href="https://www.youtube.com/watch?v=cN%5FDpYBzKso">&ldquo;Concurrency is Not Parallelism&rdquo;</a>. Illustrations and diagrams are recreated; source code taken verbatim from the slides, except for comments, which were extended in some places.</p><p><em>(You can get a set of PDF (<a href=https://rakhim.org/ziptalks/SAMPLE%2520Summary%2520of%2520Concurrency%2520Is%2520Not%2520Parallelism%2520(Rob%2520Pike).pdf>preview</a>)/HTML/epub/Kindle versions below. Name your price, starting from $1.)</em></p><script src=https://gumroad.com/js/gumroad.js></script><p><a class=gumroad-button href="https://gum.co/XZBKp?wanted=true" target=_blank data-gumroad-single-product=true>Get set</a></p><h2 id=intro>Intro</h2><p>The world is parallel: starting from the computing fundamentals, such as multi-core CPUs, and all the way to real life objects, people, planets and the Universe as a whole — everything is happening simultaneously. Yet, the computing tools that we have aren't good at expressing this world view. We can rectify this by exploring concurrency.</p><p>Go is a concurrent language. It makes it easy to design concurrent systems by providing the ability to:</p><ul><li>execute things concurrently</li><li>communicate between concurrently running processes</li></ul><p>There's a misconception about Go and concurrency: many programmers believe concurrency and parallelism are the same thing. They are not, and this talk will try to answer why.</p><h2 id=concurrency-vs-parallelism>Concurrency vs parallelism</h2><p>Here's the core of the distinction:</p><p><strong>Concurrency is composition of independently executing things</strong> (typically, functions). We often use the word &lsquo;process&rsquo; to refer to such running thing, and we don't mean &lsquo;unix process&rsquo;, but rather a process in the abstract, general sense.</p><p><strong>Parallelism is simultaneous execution of multiple things</strong>. Those things might or might not be related to each other.</p><p>Concurrency is about <strong>dealing</strong> with a lot of things at once. Parallelism is about <strong>doing</strong> a lot of things at once. The ideas are, obviously, related, but one is inherently associated with structure, the other is associated with execution. Concurrency is structuring things in a way that <em>might</em> allow parallelism to actually execute them simultaneously. But parallelism is not the goal of concurrency. <strong>The goal of concurrency is good structure.</strong></p><h3 id=analogy>Analogy</h3><p>The operating system manages multiple devices at the same time (disk, screen, keyboard, etc). They are somewhat independent and completely <em>concurrent</em> concerns. However, they aren't necessarily parallel: if the computer has only one core, several things can't possibly run simultaneously. The model here is concurrent, it is structured as a system of concurrent processes. Its reality could be parallel, depending on circumstances.</p><p>Compare this to performing matrix multiplication on a powerful GPU which contains hundreds or thousands of cores. Both the underlying idea and the reality are <em>parallel</em>, it's all about running operations at the same physical time.</p><p>Concurrency allows to structure the system in such a way that enables possible parallelism, but requires communication. Tony Hoare has written &ldquo;Communicating sequential processes&rdquo; (<a href=https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf>https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf</a>) in 1978, where he describes problems and techniques of dealing with these issues. It is the greatest paper in computer science and we highly recommend every programmer to read it. Programming languages like Erlang and Go are largely based on ideas described in it.</p><h2 id=concurrent-composition>Concurrent composition</h2><p>There's a pile of books we need to burn. We have a gopher whose job is to move books from the pile to the incinerator.</p><figure><img src=ex1_files//1.png></figure><p>One gopher is slow, so let's add another gopher. But now we need to synchronize them, since they might bump into each other, or get stuck at either side. One way to solve this is to make them communicate with each other by sending messages (like, &ldquo;I'm at the pile now&rdquo; or &ldquo;I'm on my way to the incinerator&rdquo;).</p><figure><img src=ex1_files//2.png></figure><p>How can we go faster? Double everything! Two piles of books, two incinerators! Consumption and burning can be twice as fast now. That's parallel.</p><figure><img src=ex1_files//3.png></figure><p>But try to think about it as the composition of two gopher processes. We start with a single process, and then just introduce another instance of the same process. This is called <strong>concurrent composition</strong>.</p><p>While not immediately obvious, concurrent composition is not automatically parallel! It's possible that only one gopher moves at a time. The design is still concurrent, but not parallel. This is similar to the OS example on a single core processor, where two concurrent things might not run in parallel due to technical limitations.</p><p>However, concurrent composition is automatically <strong>parallelizable</strong>.</p><h3 id=different-design>Different design</h3><p>Let's try another approach. There will be three gophers in total:</p><ol><li>One only loads the cart.</li><li>Another runs the cart to and from the incinerator.</li><li>The third unloads the cart.</li></ol><figure><img src=ex1_files//4.png></figure><p>Each gopher is an independently executing procedure.</p><p>This approach is probably faster, although, not by much. There'll definitely be problems like blocking, unnecessary waiting when the books are being loaded and unloaded, the time when the 2nd gopher runs back and nothing useful is happening, etc. Let's add another gopher!</p><h3 id=finer-grained-concurrency>Finer-grained concurrency</h3><p>Now there's a 4th gopher who returns the empty cart</p><figure><img src=ex1_files//5.png></figure><p>This version of the problem will work better than the previous version, even though we're doing <em>more work</em>. Concurrent composition of better managed pieces can run faster. In the perfect situation, with all settings optimal (number of books, timing, distance), this approach can be 4 times faster than the original version.</p><p>This is important! We improved the performance of this program by adding a concurrent procedure to existing design. We added more things and it got faster! The reason it <em>can</em> run faster is that it <em>can</em> be parallel, and the reason it can be parallel is better concurrent design.</p><p>So, we have four distinct gopher procedures:</p><ol><li>Load books onto cart.</li><li>Move cart to incinerator.</li><li>Unload cart into incinerator.</li><li>Return empty cart.</li></ol><p>Think of them as of independent procedures, running on their own, and we compose them in parallel to construct the solution. We can make it more parallel by, well, parallellizing the whole thing:</p><figure><img src=ex1_files//6.png></figure><p>Note what we're doing here: we have a well composed system which we then parallelize on a different axis to, hopefully, achieve better throughput. We understand the composition and have control over the pieces.</p><p>And what if gophers can't run simultaneously (back into the single core world)? No problem, really. Only one gopher runs at a time, and 7 others are idle. The system runs as fast as a single gopher and the overall speed is the same as the first solution. But the design is concurrent, and it is correct. This means we don't have to worry about parallelism if we do concurrency right. Parallelism is optional.</p><h3 id=yet-another-design>Yet another design</h3><p>Two gophers with a staging dump in the middle.</p><figure><img src=ex1_files//7.png></figure><p>Two similar gopher procedures running concurrently. In theory, this could be twice as fast. As before, we can parallelize it and have two piles with two staging dumps.</p><figure><img src=ex1_files//8.png></figure><p>Or try a different design still: 4 gopher approach with a single staging dump in the middle.</p><figure><img src=ex1_files//9.png></figure><p>And then double that! 16 gophers, very high throughput.</p><figure><img src=ex1_files//10.png></figure><p>Obviously, this is very simplistic and silly. But conceptually this is how you think about problems: don't think about parallel execution, think about breaking down the problem into independent components, and then compose in a concurrent manner.</p><h3 id=summary>Summary</h3><p>There are many ways to break the process down. You can easily come up with a dozen more structures. That is <strong>concurrent design</strong>. Once we have the breakdown, parallelization can fall out and correctness is easy to achieve. The design is intrinsically safe.</p><h2 id=real-world-example>Real world example</h2><p>This gophers example might look silly, but change books to web content, gophers to CPUs, carts to networking and incinerators to a web browser, and you have a web service architecture.</p><p>Let's learn a little bit of Go.</p><h3 id=goroutines>Goroutines</h3><p>If we run a regular function, we must wait until it ends executing. But if you put a keyword <code>go</code> in front of the call, the function starts running independently and you can do other things right away, at least conceptually. Not necessarily, remember: concurrent is not the same as parallel.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00a000>f</span>(<span style=color:#b44>&#34;Hello&#34;</span>)  <span style=color:#080;font-style:italic>// f runs, we wait
</span><span style=color:#080;font-style:italic></span>
<span style=color:#a2f;font-weight:700>go</span> <span style=color:#00a000>f</span>(<span style=color:#b44>&#34;Hello&#34;</span>)  <span style=color:#080;font-style:italic>// f starts running
</span><span style=color:#080;font-style:italic></span><span style=color:#00a000>g</span>()            <span style=color:#080;font-style:italic>// we don&#39;t wait for f to return
</span></code></pre></div><p>(This is similar to running a background shell process with <code>&</code>).</p><p>It is common to create thousands of goroutines in one Go program. There could be millions! Goroutines aren't free, but they're very cheap.</p><h3 id=channels>Channels</h3><p>Under the hood, goroutines are <em>like</em> threads, but they aren't OS threads. They are much cheaper, so feel free to create them as you need. They are multiplexed onto OS threads dynamically, and if one goroutine does stop and wait (for example, for input/output operation), no other goroutines are blocked because of that.</p><p>To communicate between goroutines we use <strong>channels</strong>. They allow goroutines exchange information and sync.</p><p>Here's an example. We create a <code>timerChan</code> channel of <code>time.Time</code> values (channels are typed). Then we define and run a function <code>func</code> which sleeps for some time <code>deltaT</code> and sends current time to the channel. Then, some time later, we receive a value from the channel. This receiving is blocked until there's a value. In the end, <code>completedAt</code> will store the time when <code>func</code> finished.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>timerChan <span style=color:#666>:=</span> <span style=color:#a2f>make</span>(<span style=color:#a2f;font-weight:700>chan</span> time.Time)
<span style=color:#a2f;font-weight:700>go</span> <span style=color:#a2f;font-weight:700>func</span>() {
    time.<span style=color:#00a000>Sleep</span>(deltaT)
    timerChan <span style=color:#666>&lt;-</span> time.<span style=color:#00a000>Now</span>() <span style=color:#080;font-style:italic>// send time on timerChan
</span><span style=color:#080;font-style:italic></span>}()
<span style=color:#080;font-style:italic>// Do something else; when ready, receive.
</span><span style=color:#080;font-style:italic></span><span style=color:#080;font-style:italic>// Receive will block until timerChan delivers.
</span><span style=color:#080;font-style:italic></span><span style=color:#080;font-style:italic>// Value sent is other goroutine&#39;s completion time.
</span><span style=color:#080;font-style:italic></span>completedAt <span style=color:#666>:=</span> <span style=color:#666>&lt;-</span>timerChan
</code></pre></div><h3 id=select>Select</h3><p>Goroutines and channels are the fundamental building blocks of concurrent design in Go. The last piece is the <strong>select</strong> statement. It is similar to a simple switch, but the decision is based on ability to communicate instead of equality.</p><p>The following example produces one of three outputs:</p><ol><li>If channel <code>ch1</code> is ready (has a value), first case executes.</li><li>If channel <code>ch2</code> is ready (has a value), second case executes.</li><li>If neither is ready, the default case executes.</li></ol><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>select</span> {
<span style=color:#a2f;font-weight:700>case</span> v <span style=color:#666>:=</span> <span style=color:#666>&lt;-</span>ch1:
    fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;channel 1 sends&#34;</span>, v)
<span style=color:#a2f;font-weight:700>case</span> v <span style=color:#666>:=</span> <span style=color:#666>&lt;-</span>ch2:
    fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;channel 2 sends&#34;</span>, v)
<span style=color:#a2f;font-weight:700>default</span>: <span style=color:#080;font-style:italic>// optional
</span><span style=color:#080;font-style:italic></span>    fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;neither channel was ready&#34;</span>)
}
</code></pre></div><p>If the default clause is not specified in the <code>select</code>, then the program waits for a channel to be ready. If both ready at the same time, the system picks one randomly.</p><h3 id=closures>Closures</h3><p>Go supports closures, which makes some concurrent calculations easier to express. Closures work as you'd expect. Here's a non-concurrent example:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>Compose</span>(f, g <span style=color:#a2f;font-weight:700>func</span>(x <span style=color:#0b0;font-weight:700>float</span>) <span style=color:#0b0;font-weight:700>float</span>)
                  <span style=color:#a2f;font-weight:700>func</span>(x <span style=color:#0b0;font-weight:700>float</span>) <span style=color:#0b0;font-weight:700>float</span> {
     <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>func</span>(x <span style=color:#0b0;font-weight:700>float</span>) <span style=color:#0b0;font-weight:700>float</span> {
        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#00a000>f</span>(<span style=color:#00a000>g</span>(x))
    }
}

<span style=color:#a2f>print</span>(<span style=color:#00a000>Compose</span>(sin, cos)(<span style=color:#666>0.5</span>))
</code></pre></div><h2 id=examples>Examples</h2><h3 id=launching-daemons>Launching daemons</h3><p>Here we use a closure to wrap a background operation without waiting for it. The task is to deliver input to output without waiting. The following code copies items from the input channel to the output channel.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>go</span> <span style=color:#a2f;font-weight:700>func</span>() { <span style=color:#080;font-style:italic>// copy input to output
</span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>for</span> val <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> input {
        output <span style=color:#666>&lt;-</span> val
    }
}()
</code></pre></div><p>The <code>for range</code> runs until the channel is drained (i.e. until there are no more values in it).</p><h3 id=simple-load-balancer>Simple load balancer</h3><p>You have some jobs. Let's abstract them away with a notion of a unit of work:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> Work <span style=color:#a2f;font-weight:700>struct</span> {
    x, y, z <span style=color:#0b0;font-weight:700>int</span>
}
</code></pre></div><p>A worker task has to compute something based on one unit of work. It accepts two arguments: a channel to get work <em>from</em> and a channel to output results <em>to</em>. It then loops over all values of the <code>in</code> channel, does some calculations, sleeps for some time and delivers the result to the <code>out</code> channel.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>worker</span>(in <span style=color:#666>&lt;-</span><span style=color:#a2f;font-weight:700>chan</span> <span style=color:#666>*</span>Work, out <span style=color:#a2f;font-weight:700>chan</span><span style=color:#666>&lt;-</span> <span style=color:#666>*</span>Work) {
   <span style=color:#a2f;font-weight:700>for</span> w <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> in {
      w.z = w.x <span style=color:#666>*</span> w.y
      <span style=color:#00a000>Sleep</span>(w.z)
      out <span style=color:#666>&lt;-</span> w
   }
}
</code></pre></div><p>Because of arbitrary sleeping time and blocking, a solution might feel daunting, but it is rather simple in Go. All we need to do is to create two channels (<code>in</code>, <code>out</code>) of jobs, call however many <code>worker</code> goroutines we need, then run another goroutine (<code>sendLotsOfWork</code>) which generates jobs and, finally run a regular function which receives the results in the order they arrive.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>Run</span>() {
   in, out <span style=color:#666>:=</span> <span style=color:#a2f>make</span>(<span style=color:#a2f;font-weight:700>chan</span> <span style=color:#666>*</span>Work), <span style=color:#a2f>make</span>(<span style=color:#a2f;font-weight:700>chan</span> <span style=color:#666>*</span>Work)
   <span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>0</span>; i &lt; NumWorkers; i<span style=color:#666>++</span> {
       <span style=color:#a2f;font-weight:700>go</span> <span style=color:#00a000>worker</span>(in, out)
   }

   <span style=color:#a2f;font-weight:700>go</span> <span style=color:#00a000>sendLotsOfWork</span>(in)
   <span style=color:#00a000>receiveLotsOfResults</span>(out)
}
</code></pre></div><p>This solutions works correctly whether there is parallization or not. It is <em>implicitly</em> parallel and scalable. The tools of concurrency make it almost trivial to build a safe, working, scalable, parallel design. There are no locks, mutexes, semaphores or other &ldquo;classical&rdquo; tools of concurrency. No explicit synchronization!</p><h3 id=another-load-balancer>Another load balancer</h3><figure><img src=ex1_files//balancer.png></figure><p>The load balancer needs to distribute incoming work between workers in an efficient way. The requester sends Requests to the balancer:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> Request <span style=color:#a2f;font-weight:700>struct</span> {
    fn <span style=color:#a2f;font-weight:700>func</span>() <span style=color:#0b0;font-weight:700>int</span>  <span style=color:#080;font-style:italic>// The operation to perform.
</span><span style=color:#080;font-style:italic></span>    c  <span style=color:#a2f;font-weight:700>chan</span> <span style=color:#0b0;font-weight:700>int</span>    <span style=color:#080;font-style:italic>// The channel to return the result.
</span><span style=color:#080;font-style:italic></span>}
</code></pre></div><p>Note that the request contains a channel. Since channels are first-class values in Go, they can be passed around, so each request provides its own channel into which the result should be returned.</p><p>Now the requester function. It accepts a <code>work</code> channel of Requests. It generates a channel <code>c</code> which is going to get inside the request. It sleeps for some time. Then it sends on the <code>work</code> channel a request object with some function and channel <code>c</code>. It then waits for the answer, which should appear in channel <code>c</code>, and does some further work.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>requester</span>(work <span style=color:#a2f;font-weight:700>chan</span><span style=color:#666>&lt;-</span> Request) {
    c <span style=color:#666>:=</span> <span style=color:#a2f>make</span>(<span style=color:#a2f;font-weight:700>chan</span> <span style=color:#0b0;font-weight:700>int</span>)
    <span style=color:#a2f;font-weight:700>for</span> {
        <span style=color:#080;font-style:italic>// Kill some time (fake load).
</span><span style=color:#080;font-style:italic></span>        <span style=color:#00a000>Sleep</span>(rand.<span style=color:#00a000>Int63n</span>(nWorker <span style=color:#666>*</span> <span style=color:#666>2</span> <span style=color:#666>*</span> Second))
        work <span style=color:#666>&lt;-</span> Request{workFn, c} <span style=color:#080;font-style:italic>// send request
</span><span style=color:#080;font-style:italic></span>        result <span style=color:#666>:=</span> <span style=color:#666>&lt;-</span>c              <span style=color:#080;font-style:italic>// wait for answer
</span><span style=color:#080;font-style:italic></span>        <span style=color:#00a000>furtherProcess</span>(result)
    }
}
</code></pre></div><p>Now, the worker which accepts Requests is defined by three things:</p><ol><li>The channel of Requests. This is a per-worker queue of work to do.</li><li>Number of pending tasks (the load).</li><li>An index.</li></ol><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> Worker <span style=color:#a2f;font-weight:700>struct</span> {
    requests <span style=color:#a2f;font-weight:700>chan</span> Request <span style=color:#080;font-style:italic>// work to do (buffered channel)
</span><span style=color:#080;font-style:italic></span>    pending  <span style=color:#0b0;font-weight:700>int</span>          <span style=color:#080;font-style:italic>// count of pending tasks
</span><span style=color:#080;font-style:italic></span>    index    <span style=color:#0b0;font-weight:700>int</span>          <span style=color:#080;font-style:italic>// index in the heap
</span><span style=color:#080;font-style:italic></span>}
</code></pre></div><p>This is what the worker does:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> (w <span style=color:#666>*</span>Worker) <span style=color:#00a000>work</span>(done <span style=color:#a2f;font-weight:700>chan</span> <span style=color:#666>*</span>Worker) {
    <span style=color:#a2f;font-weight:700>for</span> {
        req <span style=color:#666>:=</span> <span style=color:#666>&lt;-</span>w.requests <span style=color:#080;font-style:italic>// get Request from balancer
</span><span style=color:#080;font-style:italic></span>        req.c <span style=color:#666>&lt;-</span> req.<span style=color:#00a000>fn</span>()   <span style=color:#080;font-style:italic>// call fn and send result
</span><span style=color:#080;font-style:italic></span>        done <span style=color:#666>&lt;-</span> w           <span style=color:#080;font-style:italic>// we&#39;ve finished this request
</span><span style=color:#080;font-style:italic></span>    }
}
</code></pre></div><p>Balancer sends requests to most lightly loaded worker. The channel of requests (<code>w.requests</code>) delivers requests to each worker. The balancer tracks the number of pending requests. Each response goes directly to its requester. Once that is done, the balancer is out of the picture, because each worker communicates with its request via a unique channel.</p><p>Balancer is defined by a pool of workers and a single <code>done</code> channel through which the workers are going to tell the balancer about each completed request.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>type</span> Pool []<span style=color:#666>*</span>Worker

<span style=color:#a2f;font-weight:700>type</span> Balancer <span style=color:#a2f;font-weight:700>struct</span> {
    pool Pool
    done <span style=color:#a2f;font-weight:700>chan</span> <span style=color:#666>*</span>Worker
}
</code></pre></div><p>This is what the balancer does:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> (b <span style=color:#666>*</span>Balancer) <span style=color:#00a000>balance</span>(work <span style=color:#a2f;font-weight:700>chan</span> Request) {
    <span style=color:#a2f;font-weight:700>for</span> {
        <span style=color:#a2f;font-weight:700>select</span> {
        <span style=color:#a2f;font-weight:700>case</span> req <span style=color:#666>:=</span> <span style=color:#666>&lt;-</span>work: <span style=color:#080;font-style:italic>// received a Request...
</span><span style=color:#080;font-style:italic></span>            b.<span style=color:#00a000>dispatch</span>(req) <span style=color:#080;font-style:italic>// ...so send it to a Worker
</span><span style=color:#080;font-style:italic></span>        <span style=color:#a2f;font-weight:700>case</span> w <span style=color:#666>:=</span> <span style=color:#666>&lt;-</span>b.done: <span style=color:#080;font-style:italic>// a worker has finished ...
</span><span style=color:#080;font-style:italic></span>            b.<span style=color:#00a000>completed</span>(w)  <span style=color:#080;font-style:italic>// ...so update its info
</span><span style=color:#080;font-style:italic></span>        }
    }
}
</code></pre></div><p>It runs an infinite loop, forever checking whether there's more work to do (i.e. there's an item on the <code>work</code> channel), or there's a finished task (i.e. there's an item on the <code>done</code> channel). If there's work, dispatch it to a worker. If a job is done, update its info.</p><p>To allow the balancer to find the lightest loaded worker, we construct a heap of channels and providing methods such as:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> (p Pool) <span style=color:#00a000>Less</span>(i, j <span style=color:#0b0;font-weight:700>int</span>) <span style=color:#0b0;font-weight:700>bool</span> {
    <span style=color:#a2f;font-weight:700>return</span> p[i].pending &lt; p[j].pending
}
</code></pre></div><p>We're ready to implement the dispatcher:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>// Send Request to worker
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>func</span> (b <span style=color:#666>*</span>Balancer) <span style=color:#00a000>dispatch</span>(req Request) {
    <span style=color:#080;font-style:italic>// Grab the least loaded worker...
</span><span style=color:#080;font-style:italic></span>    w <span style=color:#666>:=</span> heap.<span style=color:#00a000>Pop</span>(<span style=color:#666>&amp;</span>b.pool).(<span style=color:#666>*</span>Worker)
    <span style=color:#080;font-style:italic>// ...send it the task.
</span><span style=color:#080;font-style:italic></span>    w.requests <span style=color:#666>&lt;-</span> req
    <span style=color:#080;font-style:italic>// One more in its work queue.
</span><span style=color:#080;font-style:italic></span>    w.pending<span style=color:#666>++</span>
    <span style=color:#080;font-style:italic>// Put it into its place on the heap.
</span><span style=color:#080;font-style:italic></span>    heap.<span style=color:#00a000>Push</span>(<span style=color:#666>&amp;</span>b.pool, w)
}
</code></pre></div><p>All it needs to do is:</p><ol><li>Grab the least loaded worker off the heap.</li><li>Send it the task by writing into its <code>requests</code> channel.</li><li>Increment its load counter.</li><li>Push it back into the heap.</li></ol><p>That's it!</p><p>The final piece is the completed function which is called every time a worker finishes processing a request. It's essentially the inverse of dispatch:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>// Job is complete; update heap
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>func</span> (b <span style=color:#666>*</span>Balancer) <span style=color:#00a000>completed</span>(w <span style=color:#666>*</span>Worker) {
    <span style=color:#080;font-style:italic>// One fewer in the queue.
</span><span style=color:#080;font-style:italic></span>    w.pending<span style=color:#666>--</span>
    <span style=color:#080;font-style:italic>// Remove it from heap.
</span><span style=color:#080;font-style:italic></span>    heap.<span style=color:#00a000>Remove</span>(<span style=color:#666>&amp;</span>b.pool, w.index)
    <span style=color:#080;font-style:italic>// Put it into its place on the heap.
</span><span style=color:#080;font-style:italic></span>    heap.<span style=color:#00a000>Push</span>(<span style=color:#666>&amp;</span>b.pool, w)
}
</code></pre></div><h3 id=lessons>Lessons</h3><ul><li>A complex problem can be broken down into easy-to-understand components.</li><li>The pieces can be composed concurrently.</li><li>The result is easy to understand, efficient, scalable, and correct.</li><li>The result is maybe even parallel.</li></ul><h3 id=one-more-example-query-a-replicated-db>One more example: query a replicated DB</h3><p>Imagine you have a replicated database (multiple shards). You send the request to all instances, but pick the one response that's first to arrive.</p><p>The function accepts an array of connections and the query to execute. It creates a buffered channel of <code>Result</code>, limited to the number of connections. Then it runs over all connections and starts a goroutine for each channel. Goroutine delivers the query, waits for response and delivers the answer to <code>ch</code>. After they all are launched, the function just returns the first value on the channel as soon as it appears.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>Query</span>(conns []Conn, query <span style=color:#0b0;font-weight:700>string</span>) Result {
    ch <span style=color:#666>:=</span> <span style=color:#a2f>make</span>(<span style=color:#a2f;font-weight:700>chan</span> Result, <span style=color:#a2f>len</span>(conns))  <span style=color:#080;font-style:italic>// buffered
</span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>for</span> _, conn <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> conns {
        <span style=color:#a2f;font-weight:700>go</span> <span style=color:#a2f;font-weight:700>func</span>(c Conn) {
            ch <span style=color:#666>&lt;-</span> c.<span style=color:#00a000>DoQuery</span>(query):
        }(conn)
    }
    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>&lt;-</span>ch
}
</code></pre></div><p>(Note that <code>_</code> on line 3 stands for an unused, unnamed variable).</p><h2 id=conclusion>Conclusion</h2><ul><li>Concurrency is powerful.</li><li>Concurrency is not parallelism.</li><li>Concurrency enables parallelism.</li><li>Concurrency makes parallelism (and scaling and everything else) easy.</li></ul><h3 id=more-information>More information</h3><ul><li>Go official page: <a href=https://golang.org>golang.org</a></li><li>Some history: <a href=https://swtch.com/~rsc/thread/>Bell Labs and CSP Threads</a></li><li>A previous talk by Rob Pike: <a href="https://www.youtube.com/watch?v=hB05UFqOtFA">Advanced Topics in Programming Languages: Concurrency/message passing Newsqueak</a></li><li><a href=https://existentialtype.wordpress.com/2011/03/17/parallelism-is-not-concurrency/>Parallelism Is Not Concurrency</a> (article by Robert Harper)</li><li><a href=https://swtch.com/~rsc/thread/cws.pdf>A Concurrent Window System</a> (paper by Rob Pike)</li><li><a href=https://swtch.com/~rsc/thread/squint.pdf>Squinting at Power Series</a> (paper by M. Douglas McIlroy)</li><li><a href=https://ai.google/research/pubs/pub61>Interpreting the Data: Parallel Analysis with Sawzall</a></li></ul><hr><p>If you liked this illustrated summary, consider supporting me by purchasing a set of PDF (<a href=https://rakhim.org/ziptalks/SAMPLE%2520Summary%2520of%2520Concurrency%2520Is%2520Not%2520Parallelism%2520(Rob%2520Pike).pdf>preview</a>), HTML epub and Kindle versions in one nice package. Name your price, starting from $1.</p><p><a class=gumroad-button href="https://gum.co/XZBKp?wanted=true" target=_blank data-gumroad-single-product=true>Get set</a></p></article></main></div><footer><p class="container-about container-center">Hi, I'm Rakhim. I teach, program, make podcasts, comics and videos on computer science at <a href=https://codexpanse.com>Codexpanse.com</a>. You can learn more about <a href=/about>my work</a> and even <a href=https://www.patreon.com/rakhim>support me</a> via Patreon.</p><div class="mt2 mb2"><form action=https://buttondown.email/api/emails/embed-subscribe/rakhim method=post target=popupwindow onsubmit="window.open('https://buttondown.email/rakhim','popupwindow')" class=embeddable-buttondown-form><label for=bd-email>Oh, and I have a monthly non-spammy personal newsletter:</label><br><input type=email name=email id=bd-email>
<input type=hidden value=1 name=embed>
<input type=submit value=Subscribe></form></div><nav class=main-nav><p><a href=/>Home</a>
<span class=text-muted>|</span>
<a href=https://blog.rakhim.org>Blog</a>
<span class=text-muted>|</span>
<a href=/about>About</a>
<span class=text-muted>|</span>
<a href=https://codexpanse.com>Courses</a>
<span class=text-muted>|</span>
<a href=/talks>Talks</a>
<span class=text-muted>|</span>
<a href=/honestly-undefined>Comics</a>
<span class=text-muted>|</span>
<a href=/bookshelf>Bookshelf</a>
<span class=text-muted>|</span>
<a href=https://www.youtube.com/c/codexpanse>YT</a>
<span class=text-muted>|</span>
<a href=https://twitter.com/freetonik>TW</a>
<span class=text-muted>|</span>
<a href=/index.xml>RSS</a><p></nav><div class=mt4></div><p class="small credits text-muted">© Rakhim Davletkaliyev, 2021<br>Powered by <a href=https://gohugo.io/>Hugo</a>, <a href=https://www.netlify.com/>Netlify and the Everett interpretation of QM.</a></p></footer></body></html>